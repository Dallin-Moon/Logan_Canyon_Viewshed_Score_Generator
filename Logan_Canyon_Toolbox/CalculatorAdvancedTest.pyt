# -*- coding: utf-8 -*-import arcpyimport osfrom arcpy.sa import RemapValueclass Toolbox:    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Toolbox"        self.alias = "toolbox"        # List of tool classes associated with this toolbox        self.tools = [ViewshedGenerator]class ViewshedGenerator:    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "ViewshedGenerator2"        self.description = ""    def getParameterInfo(self):        """Define the tool parameters."""        params = [            arcpy.Parameter(                displayName="Observer Points",                name="observer_points",                datatype="DEFeatureClass",                parameterType="Required",                direction="Input"            ),            arcpy.Parameter(                displayName="Elevation Raster",                name="elevation_raster",                datatype="GPRasterLayer",                parameterType="Required",                direction="Input"            ),            arcpy.Parameter(                displayName="Buffer Distance (meters)",                name="buffer_distance",                datatype="GPLong",                parameterType="Required",                direction="Input"            ),            arcpy.Parameter(                displayName="Output GDB",                name="output_gdb",                datatype="DEWorkspace",                parameterType="Required",                direction="Input"            ),            arcpy.Parameter(                displayName="Scoring Parameters",                name="scoring_parameters",                datatype="DEFeatureClass",                parameterType="Required",                direction="Input",                multiValue=True            )]        return params    def isLicensed(self):        """Set whether the tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter. This method is called after internal validation."""        return    def generateviewshed(self, elevation_raster, observer_points, output, output_location):        try:            viewshed = arcpy.sa.Viewshed(elevation_raster, observer_points, "", "CURVED_EARTH", "")            # declare output file (including file name)            output_location = os.path.join(output_location, output)            # save viewshed at that location            viewshed.save(output_location)            # return viewshed to save viewshed in the list.            return viewshed        except arcpy.ExecuteError:            arcpy.AddMessage(arcpy.GetMessages(2))  # Print any arcpy error messages        except Exception as e:            arcpy.AddMessage(e)  # Print other exceptions if any    def buffer(self, points, buffer, distance, num):        # declare output file name with qualifier(num)        output = buffer + str(num)        # generate buffer        try:            file = arcpy.analysis.Buffer(points, output, distance, "", "", "", "")            # return file to add to the buffer list            return file        except arcpy.ExecuteError:            arcpy.AddMessage(arcpy.GetMessages(2))  # Print any arcpy error messages        except Exception as e:            arcpy.AddMessage(e)  # Print other exceptions if any    def extract_by_mask(self, buffer_output, viewshed, i, output_location):        try:            extracted = arcpy.sa.ExtractByMask(viewshed, buffer_output, "", "")            # save extracted file            extracted.save(os.path.join(output_location, "extracted"+str(i)))            # return extracted file to add it to the list            return extracted        except arcpy.ExecuteError:            arcpy.AddMessage(arcpy.GetMessages(2))  # Print any arcpy error messages        except Exception as e:            arcpy.AddMessage(e)  # Print other exceptions if any    def reclassify(self, raster, output_fc, location):        # reclassify raster to only include the covered area, excluding areas not covered(value = 0)        try:            # reclassify            reclass = arcpy.sa.Reclassify(raster, "Value", RemapValue([[0, "NODATA"], [1, 1]]), "")            # save reclassified file            reclass.save(output_fc)            # print to confirm to user that the reclassification was successful            # return reclassified output to add it to a list            return reclass        except arcpy.ExecuteError:            arcpy.AddMessage(arcpy.GetMessages(2))  # Print any arcpy error messages        except Exception as e:            arcpy.AddMessage(e)  # Print other exceptions if any    def dissolve(self, features, output):        # merge polygon features together        try:            merged = arcpy.management.Merge(features, "in_memory\\temp_merge")            return arcpy.management.Dissolve(merged, output)        except arcpy.ExecuteError:            arcpy.AddMessage(arcpy.GetMessages(2))  # Print any arcpy error messages        except Exception as e:            arcpy.AddMessage(e)  # Print other exceptions if any    def spatialJoin(self, polygon, data, output, type):        try:            # join covered area with other features            joined_features = arcpy.analysis.SpatialJoin(polygon, data, output, type, "KEEP_ALL")            # return joined feature class            return joined_features        except arcpy.ExecuteError:            arcpy.AddMessage(arcpy.GetMessages(2))  # Print any arcpy error messages        except Exception as e:            arcpy.AddMessage(e)  # Print other exceptions if any    def toPolygon(self, dataset, output_polygon, char):        try:            # Convert raster to polygon            output_polygon += char            arcpy.RasterToPolygon_conversion(dataset, output_polygon, "NO_SIMPLIFY", "VALUE")            # return output polygon for further analysis            return output_polygon        except arcpy.ExecuteError:            arcpy.AddMessage(arcpy.GetMessages(2))  # Print any arcpy error messages        except Exception as e:            arcpy.AddMessage(e)  # Print other exceptions if any    def aggregate(self, input, output, distance):        try:            return arcpy.cartography.AggregatePolygons(input, output, distance)        except arcpy.ExecuteError:            arcpy.AddMessage(arcpy.GetMessages(2))  # Print any arcpy error messages        except Exception as e:            arcpy.AddMessage(e)  # Print other exceptions if any    def identify_multivalue(self, fc):        with arcpy.da.SearchCursor(fc, ["score"]) as cursor:            try:                first_row = next(cursor)                score = first_row[0]            except StopIteration:                return False  # Empty feature class, no scores to compare            for row in cursor:                if row[0] != score:                    return True        return False    def calculate_score(self, viewshed, data_list, output_name, output_location):        # declare name qualifier        num = 0        # temporary list for polygons        polygon_list = []        # iterate through all viewshed rasters        for raster in viewshed:            # increment qualifier by num            num += 1            # declare new output name            output = output_name + str(num)            # reclassify viewsheds            reclassified = self.reclassify(raster, output, output_location)            # convert raster to polygon and add to list of polygons            polygon = self.toPolygon(reclassified, output, "poly" + str(num))            polygon_list.append(self.aggregate(polygon, "final_polygon" + str(num), "120 Meters"))        arcpy.AddMessage("performing joins")        score_list = []        dissolved = []        for poly in range(len(polygon_list)):            original = polygon_list[poly]            score = 0            results = []            for i, dataset in enumerate(data_list, start=1):                multivalue = self.identify_multivalue(dataset)                path = str(dataset)                name = path.split("\\")[-1]                uneditable_fields = [f.name for f in arcpy.ListFields(dataset) if not f.editable]                # Define the fields to keep (score field and required system fields)                keepers = uneditable_fields + ["Shape", "Score"]  # Add any additional fields you need to keep                fields_to_delete = [f.name for f in arcpy.ListFields(dataset) if f.name not in keepers]                arcpy.CopyFeatures_management(dataset, "in_memory\\compact" + str(poly) + "_" + str(i))                if fields_to_delete:                    arcpy.DeleteField_management("in_memory\\compact" + str(poly) + "_" + str(i), fields_to_delete)                temp_fc = f"in_memory\\temp_join_{poly}_{i}"  # Store intermediate results in memory                output_fc = self.spatialJoin(original, "in_memory\\compact" + str(poly) + "_" + str(i), temp_fc, "JOIN_ONE_TO_ONE")                scored = self.add(output_fc, "score", "join_count", multivalue)                score += scored[0]                counted = scored[1]                results.append([name, scored[0], counted])            dissolved.append(self.dissolve(original, "Final_Cell_Range" + str(poly)))            # Save the final output to disk before exporting to Excel            final_fc = f"{output_location}\\FinalJoined{poly}"            arcpy.CopyFeatures_management(output_fc, final_fc)            arcpy.AddMessage([f.name for f in arcpy.ListFields(final_fc)])            score_list.append([poly, score, results])        arcpy.AddMessage(dissolved)        arcpy.management.Merge(dissolved, "Cell_Ranges")        return score_list    def add(self, table, score, count, multivalue):        total_score = 0        counter = 0        with arcpy.da.SearchCursor(table, [score, count]) as cursor:            for row in cursor:                score_val, count_val = row                # Skip rows with None values in score or count                if score_val is None or count_val is None:                    continue                if not multivalue:                    counter += count_val                    total_score += score_val * count_val                else:                    total_score = max(total_score, score_val)        if multivalue:            counter = 1        return [total_score, counter]    def execute(self, parameters, messages):        """The source code of the tool."""        observer_points = parameters[0].valueAsText        elevation_raster = parameters[1].valueAsText        buffer_distance = parameters[2].value        output_location = parameters[3].valueAsText        criteria = parameters[4].valueAsText.split(";")        arcpy.env.workspace = output_location        temp = []        for i in criteria:            name = i.split("\\")[-1]            type = arcpy.Describe(i)            arcpy.AddMessage(type.shapeType)            if type.shapeType == "Polyline" and not self.identify_multivalue(i):                arcpy.AddMessage("dissolving for join")                original = arcpy.management.Dissolve(i, f"in_memory\\{name}", ["score"])                temp.append(original)            else:                temp.append(i)        criteria = temp        arcpy.AddMessage(criteria)        buffer_fc = os.path.join(output_location, "buffer") # Pathway to buffer location        point_list = []        viewshed_list = []        buffer_list = []        extracted_viewshed = []        # Use a Search Cursor to loop through existing points and add them to the list        with arcpy.da.SearchCursor(observer_points, ["SHAPE@"]) as cursor:            for row in cursor:                point_list.append(row[0])        # Now you can loop through the point_list and perform other functions        output_name_qualifier = 0        for point in point_list:            output_name_qualifier += 1            output = "viewshed" + str(output_name_qualifier)            if arcpy.Exists("in_memory/temp_point_fc"):                arcpy.Delete_management("in_memory/temp_point_fc")            temp_point_fc = arcpy.management.CopyFeatures([point], "in_memory/temp_point_fc")            fields = [f.name for f in arcpy.ListFields(temp_point_fc)]            if "OFFSETA" not in fields:                arcpy.AddField_management(temp_point_fc, "OFFSETA", "DOUBLE")  # Add field if it doesn't exist            # Update the field for all points            with arcpy.da.UpdateCursor(temp_point_fc, ["OFFSETA"]) as cursor:                for row in cursor:                    row[0] = 20  # Set OFFSETA to 20                    cursor.updateRow(row)            viewshed_list.append(self.generateviewshed(elevation_raster, temp_point_fc, output, output_location))            arcpy.AddMessage(output + "complete!")        # Clean up intermediate data        arcpy.management.Delete(temp_point_fc)        num = 0  # buffer name qualifier        arcpy.AddMessage("Buffering!")        for i in point_list:            num += 1            buffer_list.append(self.buffer(i, buffer_fc, buffer_distance, num))        # for each buffer in the list, extract viewshed by corresponding buffer and add to extracted_viewshed list        num = 0        for i in buffer_list:            num += 1            extracted_viewshed.append(self.extract_by_mask(i, viewshed_list[num - 1], num, output_location))        arcpy.AddMessage("extraction complete")        # verify data type of viewshed. Testing purposes only, does not affect script        test = arcpy.Describe(extracted_viewshed[0])        arcpy.AddMessage(test.dataType)        # Calculate score of viewsheds        scores = self.calculate_score(extracted_viewshed, criteria, "Final_Score", output_location)        arcpy.AddMessage(scores)        arcpy.management.AddField(observer_points, "score", "DOUBLE")        with arcpy.da.UpdateCursor(observer_points, ["score"]) as cursor:            for i, row in enumerate(cursor):                row[0] = scores[i][1]                cursor.updateRow(row)        for i, dataset in enumerate(criteria):            path = str(dataset)            name = path.split("\\")[-1]            arcpy.management.AddField(observer_points, name, "TEXT")            with arcpy.da.UpdateCursor(observer_points, [name]) as cursor:                for j, row in enumerate(cursor):                    text = f"Score: {scores[j][2][i][1]} Count: {scores[j][2][i][2]}"                    row[0] = text                    cursor.updateRow(row)        # confirm that script ran till the end        arcpy.AddMessage("done")        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return